# TheoryCraft

```elixir
Mix.install(
  [
    {:tzdata, "~> 1.1"},
    {:theory_craft, path: "D:/Documents/Dev/Elixir/theorycraft", override: true},
    {:theory_craft_ta, path: "D:/Documents/Dev/Elixir/theory_craft_ta", override: true},
    {:kino_theory_craft,
     path: "D:/Documents/Dev/Elixir/theorycraft/.deps/kino_theory_craft"}
  ],
  consolidate_protocols: false
)

Application.put_env(:elixir, :time_zone_database, Tzdata.TimeZoneDatabase)
```

## TheoryCraft

```elixir
defmodule TheoryCraft.Test do
  @moduledoc """
  Documentation for `TheoryCraft`.
  """

  import TheoryCraft.MarketSimulator

  alias TheoryCraft.MarketSimulator
  alias TheoryCraft.Utils

  ## Public API

  def test() do
    dir = "D:/Documents/Dev/trading/python/data"
    
    filename = "XAUUSD_Ticks_18.08.2025-18.08.2025.csv"
    full_path = Path.join(dir, filename)
    opts = dukascopy_opts()
    
    # filename = "ticks_XAUUSD_Minute_20240101_230202_20241231_215859.csv"
    # full_path = Path.join(dir, filename)
    # opts = ctrader_opts()

    stream =
      %MarketSimulator{}
      # |> add_data(memory_stream, name: "ticks")
      |> add_data_ticks_from_csv(full_path, opts)
      |> resample("D", data: "XAUUSD", name: "XAUUSD_daily")
      |> stream()
      |> Enum.take(3)
      |> IO.inspect()

    count = time("Stream", fn -> Enum.count(stream) end)
    IO.puts("Count: #{count}")
  end

  ## Private functions

  defp dukascopy_opts() do
    [
      name: "XAUUSD",
      time: "Local time",
      ask: "Ask",
      bid: "Bid",
      ask_volume: "AskVolume",
      bid_volume: "BidVolume",
      skip_headers: false,
      time_format: :dukascopy
    ]
  end

  defp ctrader_opts() do
    [
      name: "XAUUSD",
      time: "Timestamp",
      ask: "Ask",
      bid: "Bid",
      ask_volume: "AskVolume",
      bid_volume: "BidVolume",
      skip_headers: false
    ]
  end

  defp time(name, fun) do
    {time, value} = :timer.tc(fun, :millisecond)
    IO.puts("#{name} took #{Utils.duration_ms_to_string(time)}")
    value
    end
end


TheoryCraft.Test.test()
```

```elixir
# dir = "D:/Documents/Dev/trading/python/data"
# filename = "XAUUSD_Ticks_18.08.2025-18.08.2025.csv"
# full = Path.join(dir, filename)

# content =
#   full
#   |> File.stream!()
#   |> Enum.take(51)
#   |> Enum.join()

# File.write!(
#   "D:/Documents/Dev/Elixir/theorycraft/test/fixtures/XAUUSD_ticks_dukascopy.csv",
# content
# )


# %Strategy{}
# # |> add_data_from_csv("tick_xauusd.csv", name: "xauusd_ticks")
# |> add_data("tick_xauusd.csv")
# |> resample("m5")
# |> resample("D", data: 0, name: "xauusd_daily")
# |> add_indicator(TheoryCraft.Indicators.SMA, period: 14, data: "xauusd_daily", name: "sma_14")
# |> add_indicator(TheoryCraft.Indicators.Supertrend, period: 14, name: "supertrend_14", data: 0)
# |> add_strategy(TheoryCraft.Strategies.MyStrategy)
# |> set_balance(100_000)
# |> set_commission(0.001)
```

<!-- livebook:{"attrs":"e30","chunks":[],"kind":"Elixir.KinoTheoryCraft.TheoryCraftCell","livebook_object":"smart_cell"} -->

```elixir

```

## KinoTheoryCraft

```elixir
alias TheoryCraft.DataFeeds.TicksCSVDataFeed

filename = "D:/Documents/Dev/trading/python/data/XAUUSD_Ticks_18.08.2025-18.08.2025.csv"

opts = [
  file: filename,
  name: "XAUUSD",
  time: "Local time",
  ask: "Ask",
  bid: "Bid",
  ask_volume: "AskVolume",
  bid_volume: "BidVolume",
  skip_headers: false,
  time_format: :dukascopy
]

input_file = 
  opts
  |> TicksCSVDataFeed.stream!()
  |> KinoTheoryCraft.Input.stream(name: Path.basename(filename))
```

<!-- livebook:{"attrs":"eyJpbnB1dF92YXJpYWJsZSI6ImlucHV0X2ZpbGUiLCJ0YXNrX2lkIjoicmVzYW1wbGUiLCJ0aW1lZnJhbWVfbXVsdGlwbGllciI6NSwidGltZWZyYW1lX3VuaXQiOiJtIiwidGltZXpvbmUiOiJFdXJvcGUvUGFyaXMifQ","chunks":[[0,2508]],"kind":"Elixir.KinoTheoryCraft.TheoryCraftCell","livebook_object":"smart_cell"} -->

```elixir
alias KinoTheoryCraft.Control.{Chart, ChartController, Streamer}
alias TheoryCraft.MarketSimulator
chart = Chart.new([], "Europe/Paris" || "Etc/UTC")
initial_speed = 100
controller = ChartController.new(speed: initial_speed, status: :paused)
input = input_file
timeframe = "m5"
{:ok, streamer_ref} = Agent.start_link(fn -> nil end)
{:ok, speed_ref} = Agent.start_link(fn -> initial_speed end)

create_streamer = fn speed ->
  resampled_stream =
    %MarketSimulator{}
    |> MarketSimulator.add_data(input.stream, name: "data")
    |> MarketSimulator.resample(timeframe, name: "data_#{timeframe}")
    |> MarketSimulator.stream()

  {:ok, streamer} =
    Streamer.start_link(resampled_stream,
      on_events: fn market_events ->
        bars =
          for market_event <- market_events do
            market_event.data["data_#{timeframe}"]
          end

        :ok = Chart.update_batch(chart, bars)
      end,
      mode: :manual,
      speed: speed
    )

  :ok = Chart.set_streamer(chart, streamer)
  streamer
end

initial_streamer = create_streamer.(initial_speed)
Agent.update(streamer_ref, fn _ -> initial_streamer end)

controller
|> ChartController.stream()
|> Kino.listen(fn event ->
  current_streamer = Agent.get(streamer_ref, & &1)

  case event.type do
    :play ->
      case Streamer.play(current_streamer) do
        :ok -> ChartController.set_status(controller, :playing)
        {:error, :invalid_state} -> :ok
      end

    :pause ->
      case Streamer.pause(current_streamer) do
        :ok -> ChartController.set_status(controller, :paused)
        {:error, :invalid_state} -> :ok
      end

    :step ->
      Streamer.step(current_streamer)

    :fast_step ->
      Streamer.fast_step(current_streamer)

    :speed_change ->
      Streamer.set_speed(current_streamer, event.speed)
      Agent.update(speed_ref, fn _ -> event.speed end)

    :reset ->
      current_speed = Agent.get(speed_ref, & &1)

      if Process.alive?(current_streamer) do
        GenServer.stop(current_streamer, :normal)
      end

      new_streamer = create_streamer.(current_speed)
      Agent.update(streamer_ref, fn _ -> new_streamer end)
      Chart.clear(chart)
      ChartController.set_status(controller, :paused)
  end
end)

export_button =
  Kino.Download.new(fn -> raise "unsupported yet" end,
    label: "Export CSV",
    filename: "download.csv"
  )

bottom_row = Kino.Layout.grid([controller, export_button], columns: 1, gap: 12)
Kino.Layout.grid([chart, bottom_row], boxed: true, gap: 12)
```

```elixir
require TheoryCraftTA.TA, as: TA

alias TheoryCraft.MarketSimulator

Logger.configure(level: :info)

%MarketSimulator{}
|> MarketSimulator.add_data(input_file.stream, name: "data")
|> MarketSimulator.resample("m5", name: "data_m5")
|> MarketSimulator.add_indicators_layer([
  TA.sma(data[:ask], 2),
  TA.ema(data_m5[:close], 3),
])
|> MarketSimulator.stream()
|> Enum.at(3300)
# |> Enum.slice(3300..3302)
```
